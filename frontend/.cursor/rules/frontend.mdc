---
description: Frontend architecture rules and constraints
alwaysApply: true
---

# Frontend Architecture Rules

## Component Organization (MANDATORY)

### Large Components MUST Be Split

When a component file exceeds ~300 lines or contains multiple distinct UI sections:
- Convert to a **folder** with the same name
- Extract sub-components into `components/` subfolder
- Extract hooks into `hooks/` subfolder
- Use `index.tsx` to re-export the main component

Example:
```
# BAD: Single 900-line file
src/pages/OrderDetail.tsx

# GOOD: Organized folder structure
src/pages/OrderDetail/
├── index.tsx                    # Re-export
├── OrderDetail.tsx              # Main component (~200 lines)
├── ImageCard.tsx                # Major sub-component
├── components/
│   ├── OriginalImageDisplay.tsx
│   ├── ColoringControls.tsx
│   ├── SvgControls.tsx
│   ├── VersionTabs.tsx
│   └── ImagePreviewDialog.tsx
└── hooks/
    └── useImageMutations.ts
```

## Order ID (ULID) Usage

- `order.id` is a ULID string (26 characters), used for:
  - URL parameters (`/orders/:orderId`)
  - API calls
  - Query keys
  - Mercure subscriptions
- `order.order_number` is the display value (e.g., `#1270` for Shopify, `#M1000` for manual)
- `order.shopify_id` is optional (only for Shopify orders, for "Open in Shopify" button)

```typescript
// URL routing
<Route path="/orders/:orderId" element={<OrderDetail />} />

// In component
const { orderId } = useParams<{ orderId: string }>();

// Display to user
<h1>{order.order_number}</h1>  // Shows "#1270"

// Link to order
<Link to={`/orders/${order.id}`}>{order.order_number}</Link>
```

## Custom Hooks Pattern

### Extract Related Mutations

When a component has multiple related mutations, extract to a custom hook:

```typescript
// hooks/useImageMutations.ts
import { getGetOrderQueryKey } from "@/api/generated/orders/orders";

export function useImageMutations(imageId: number, orderId: string) {
  const generateColoringMutation = useMutation({
    mutationFn: () => generateImageColoring(imageId),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: getGetOrderQueryKey(orderId) }),
  });

  const generateSvgMutation = useMutation({...});
  const selectColoringMutation = useMutation({...});

  return {
    generateColoringMutation,
    generateSvgMutation,
    selectColoringMutation,
  };
}
```

## Code Duplication Rules

### NEVER Duplicate Logic

- Extract shared logic to `lib/` utilities
- Create helper functions for repeated patterns
- Use shared hooks for common data fetching patterns

### Status Checking Utilities

Extract to `lib/statusHelpers.ts`:

```typescript
export const COLORING_PROCESSING_STATUSES = [
  "queued", "processing", "runpod_submitting",
  "runpod_submitted", "runpod_queued", "runpod_processing"
] as const;

export function isColoringProcessing(versions: ColoringVersion[]): boolean {
  return versions.some((cv) =>
    COLORING_PROCESSING_STATUSES.includes(cv.status as any)
  );
}

export function hasCompletedColoring(versions: ColoringVersion[]): boolean {
  return versions.some((cv) => cv.status === "completed");
}
```

### Display Label Helpers

Put in `types/index.ts` alongside status display configs:

```typescript
export function getShapeStackingLabel(value: string): string {
  const labels: Record<string, string> = {
    stacked: "Vrstvené",
    none: "Žádné",
  };
  return labels[value] || value;
}
```

## API Layer (Generated SDK)

### Use Generated SDK

**NEVER** write manual API functions. Use the Orval-generated SDK:

```typescript
// BAD - manual API call
const { data } = useQuery({
  queryKey: ["orders"],
  queryFn: () => fetch("/api/v1/orders").then(r => r.json()),
});

// GOOD - generated hook
import { useListOrders } from "@/api/generated/orders/orders";
const { data } = useListOrders();
```

For backward compatibility, `@/lib/api.ts` re-exports generated types and wrapper functions.

### Generated Query Keys (MANDATORY)

**ALWAYS** use generated query key functions for both `useQuery` and cache invalidation. This ensures type-safe, consistent query keys across the entire codebase.

```typescript
import { getListOrdersQueryKey, getGetOrderQueryKey } from "@/api/generated/orders/orders";

// In useQuery - ALWAYS use generated key (orderId is ULID string)
const { data } = useQuery({
  queryKey: getGetOrderQueryKey(orderId),
  queryFn: () => fetchOrder(orderId),
});

// In mutations - ALWAYS use generated key for invalidation
const mutation = useMutation({
  mutationFn: () => syncOrder(orderId),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: getGetOrderQueryKey(orderId) });
    queryClient.invalidateQueries({ queryKey: getListOrdersQueryKey() });
  },
});
```

**WARNING**: Using different query keys (e.g., `["order", id]` vs `getGetOrderQueryKey(id)`) will cause cache misses and bugs. TypeScript cannot catch this - the generated keys ensure consistency.

### Mercure Event Types

Use generated event types from SDK (do NOT define manually):

```typescript
import type {
  ImageStatusEvent,
  ImageUpdateEvent,
  ListUpdateEvent,
  OrderUpdateEvent,
} from "@/api/generated/schemas";

// Union type for all events
type MercureEvent = ImageStatusEvent | ImageUpdateEvent | ListUpdateEvent | OrderUpdateEvent;

const event = data as MercureEvent;
if (event.type === "image_status") {
  // TypeScript knows event.order_id and event.image_id exist
}
```

Note: Events use `order_id` (ULID string), not `shopify_id`.

### SDK Regeneration

- Run `npm run generate:api` after backend API changes
- SDK is auto-generated on `docker-compose up`
- Generated files are in `src/api/generated/` (gitignored)

### API URL Configuration

`VITE_API_URL` environment variable is the **base URL only** (without `/api/v1`):
- Local dev (with Vite proxy): `""` (empty string, default)
- Production/Docker: `http://backend:8000`

The Orval-generated code already includes `/api/v1` in the endpoint paths.

`ORVAL_API_URL` controls where Orval fetches the OpenAPI schema:
- Local dev: Not set (defaults to `http://localhost:8000/openapi.json`)
- Docker: `http://backend:8000/openapi.json`

### HTTP Methods

- `GET` - Read operations
- `POST` - Create resources, trigger actions
- `PUT` - Update resource state (e.g., selecting a version)

## State Management

### TanStack Query for Server State

- Use `useQuery` for data fetching
- Use `useMutation` for modifications
- Invalidate queries on mutation success
- **ALWAYS** use generated query key functions (see "Generated Query Keys" section above)

### Local State

- Use `useState` for UI-only state (modals, form inputs, tabs)
- Keep state as close to where it's used as possible
- Lift state only when multiple components need it

## Component Props

### Use Interface for Props

```typescript
interface ImageCardProps {
  image: OrderImage;
  orderId: string;  // ULID string
  onPreview?: (src: string, alt: string) => void;
}

function ImageCard({ image, orderId, onPreview }: ImageCardProps) {
  // ...
}
```

### Avoid Prop Drilling

- Pass only what's needed
- Use context for deeply shared state
- Extract hooks that encapsulate logic + data

## File Naming

- Components: `PascalCase.tsx` (e.g., `ImageCard.tsx`)
- Hooks: `camelCase.ts` with `use` prefix (e.g., `useImageMutations.ts`)
- Utilities: `camelCase.ts` (e.g., `statusHelpers.ts`)
- Types: `index.ts` in `types/` folder

## Icon System

Icons are auto-generated from usage. To add a new icon:
1. Use `<Icon name="mdi-icon-name" />` in your component
2. The Vite plugin will automatically:
   - Scan for icon usage
   - Add the icon to `IconSprite.tsx`
   - Update the `IconName` type

Icon naming: `{prefix}-{name}` (e.g., `mdi-fullscreen`, `mdi-refresh`)
