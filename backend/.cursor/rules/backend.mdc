---
description: Backend architecture rules and constraints
alwaysApply: true
---

# Backend Architecture Rules

## Service Layer Architecture (MANDATORY)

**NEVER** put business logic directly in API route handlers. API routes MUST be thin wrappers that:
1. Parse and validate request parameters
2. Call service methods
3. Dispatch Dramatiq tasks for background processing
4. Map service exceptions to HTTP responses
5. Return serialized responses

### Service Layer Structure

```
app/services/
├── exceptions.py              # Base service exceptions (ServiceError, NotFoundError, ValidationError)
├── orders/                    # Domain: order management
│   ├── exceptions.py          # OrderNotFound, ImageNotFound, etc.
│   ├── order_service.py
│   ├── image_service.py
│   ├── image_download_service.py  # Image download/upload with S3
│   └── shopify_sync_service.py    # Shopify order sync logic
├── coloring/                  # Domain: image processing
│   ├── exceptions.py          # ColoringVersionNotFound, SvgVersionNotFound, etc.
│   ├── coloring_service.py
│   └── vectorizer_service.py
├── storage/                   # S3 storage abstraction
│   ├── storage_service.py     # S3StorageService
│   └── paths.py               # OrderStoragePaths key generation
└── external/                  # Third-party API clients (all classes)
    ├── mercure.py             # MercureService
    ├── runpod.py              # RunPodService
    ├── shopify.py             # ShopifyService
    └── vectorizer.py          # VectorizerApiService
```

**ALL services MUST be classes.** No function-based services are allowed.

### Service Class Pattern

```python
class OrderService:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_order(self, order_id: str) -> Order:
        """Business logic here, raises custom exceptions."""
        order = await self._fetch_order(order_id)  # order_id is ULID string
        if not order:
            raise OrderNotFound()
        return order
```

### API Route Pattern

```python
@router.get("/orders/{order_id}", response_model=OrderDetailResponse, operation_id="getOrder")
async def get_order(order_id: str, service: OrderServiceDep) -> OrderDetailResponse:
    try:
        order = await service.get_order(order_id)  # order_id is ULID string
        return OrderDetailResponse.from_model(order)
    except OrderNotFound:
        raise HTTPException(404, "Order not found")
```

### Operation IDs (MANDATORY)

**ALL** FastAPI endpoints MUST have explicit `operation_id` for clean SDK generation:

```python
@router.get("/orders/{order_id}", response_model=OrderDetailResponse, operation_id="getOrder")
```

Naming convention:
- GET single resource: `get{Resource}` (e.g., `getOrder`, `getOrderImage`)
- GET list: `list{Resources}` (e.g., `listOrders`, `listVersions`)
- POST action: `{action}{Resource}` (e.g., `syncOrder`, `generateImageColoring`)
- PUT update: `select{Resource}` (e.g., `selectVersion`)
- POST retry: `retry{Resource}` (e.g., `retryVersion`)

## Order ID and ULID (MANDATORY)

- `Order.id` is a ULID string stored as PostgreSQL UUID (16 bytes)
- **ALL** API paths use `order_id` (ULID), not `shopify_id`
- `Order.order_number` is the display value (e.g., `#1270` for Shopify, `#M1000` for manual)
- `Order.shopify_id` and `Order.shopify_order_number` are optional (for Shopify orders only)

```python
from ulid import ULID

# Generate new ULID
order_id = str(ULID())

# Custom SQLAlchemy type: app/models/types.py -> ULIDType
# Stores as UUID in PostgreSQL, presents as string in Python/API
```

## S3 Storage (MANDATORY)

### S3StorageService

```python
from app.services.storage.storage_service import S3StorageService
from app.services.storage.paths import OrderStoragePaths

storage = S3StorageService()
paths = OrderStoragePaths(order)

# Upload file
key = paths.original_image(line_item, image, "jpg")
file_ref = await storage.upload(upload_to=key, data=image_bytes, content_type="image/jpeg")

# Download file
data = await storage.download(file_ref)

# Get public URL
url = storage.get_public_url(file_ref)  # Uses S3_PUBLIC_URL (mandatory)
```

### S3ObjectRef (File References)

All file references use `S3ObjectRefData` stored as JSONB:

```python
from app.models.types import S3ObjectRef, S3ObjectRefData

class Image(SQLModel, table=True):
    file_ref: S3ObjectRefData | None = Field(
        default=None,
        sa_column=Column(S3ObjectRef, nullable=True)
    )
```

### OrderStoragePaths Key Generation

```python
from app.services.storage.paths import OrderStoragePaths

paths = OrderStoragePaths(order)
paths.original_image(line_item, image, "jpg")      # orders/{ulid}/items/{pos}/original/image_{pos}.jpg
paths.coloring_version(line_item, image, version)  # orders/{ulid}/items/{pos}/coloring/v{n}/image_{pos}.png
paths.svg_version(line_item, image, version)       # orders/{ulid}/items/{pos}/svg/v{n}/image_{pos}.svg
```

## AutoIncrementOnConflict (Race-Safe Sequences)

Use `AutoIncrementOnConflict` for auto-incrementing fields with race condition handling:

```python
from app.models.utils.auto_increment import AutoIncrementOnConflict
from app.models.order import LINE_ITEM_POSITION_CONSTRAINT

async for attempt in AutoIncrementOnConflict(
    session=self.session,
    model_class=LineItem,
    increment_column=LineItem.position,
    filter_columns={LineItem.order_id: order_id},
    constraint=LINE_ITEM_POSITION_CONSTRAINT,
):
    async with attempt:
        line_item = LineItem(order_id=order_id, position=attempt.value, ...)
        self.session.add(line_item)
        await self.session.flush()
```

This handles:
1. Calculates next value with `MAX(column) + 1`
2. Creates savepoint before insert
3. Retries on unique constraint violation
4. Rolls back to savepoint and recalculates on conflict

## Dramatiq Tasks Architecture (MANDATORY)

Tasks MUST be thin wrappers that:
1. Set up database session via `task_db_session()`
2. Call service methods for ALL business logic
3. Handle task-specific concerns (retries, timeouts)
4. Publish Mercure notifications for status updates

**NEVER** put business logic in tasks. If new logic is needed, add a service method first.

### Task Pattern

```python
from app.tasks.utils import task_db_session
from app.tasks.decorators import task_recover

@task_recover(ColoringService.get_incomplete_versions)
@dramatiq.actor(max_retries=3, min_backoff=1000, max_backoff=60000)
def generate_coloring(version_id: int) -> None:
    async def _run():
        async with task_db_session() as session:
            service = ColoringService(session)
            await service.process_version(version_id)
    asyncio.run(_run())
```

### External API Calls

- **NEVER** call external APIs from FastAPI workers (Shopify, RunPod, Vectorizer)
- **ALL** external API calls MUST happen in Dramatiq tasks
- External services are classes that handle API calls (e.g., `RunPodService`, `VectorizerApiService`)
- Tasks instantiate services and handle orchestration and error handling

### Tasks Folder Structure

Tasks are organized to mirror the services structure:

```
app/tasks/
├── __init__.py
├── decorators.py        # @task_recover decorator
├── recovery.py          # Task recovery utilities
├── utils.py             # task_db_session context manager
├── orders/              # mirrors services/orders/
│   ├── __init__.py
│   ├── fetch_shopify.py       # Batch fetch orders
│   ├── image_download.py      # Download/upload order images to S3
│   └── order_ingestion.py     # Ingest single order
└── coloring/            # mirrors services/coloring/
    ├── __init__.py
    ├── generate_coloring.py   # Generate coloring via RunPod
    └── vectorize_image.py     # Convert to SVG via Vectorizer.ai
```

## Import Rules (MANDATORY)

### No Re-exports (HARD CONSTRAINT)

- **NEVER** re-export from `__init__.py` files - keep them empty (docstring only)
- **NEVER** create "backward compatibility" modules that only re-export from elsewhere
- **ALWAYS** use explicit imports from the actual module where code is defined
- Use `TYPE_CHECKING` imports for type hints that would cause circular imports

### Examples

```python
# BAD - importing from package __init__.py
from app.services import ColoringService

# GOOD - explicit imports from actual modules
from app.services.coloring.coloring_service import ColoringService
from app.utils.shopify_helpers import build_customer_name
from app.services.external.mercure import MercureService
from app.services.storage.storage_service import S3StorageService

# Using external services (always instantiate as classes)
mercure = MercureService()
await mercure.publish_order_update(order_id)  # order_id is ULID string

storage = S3StorageService()
file_ref = await storage.upload(upload_to=key, data=data, content_type="image/png")
```

## Custom Exceptions (MANDATORY)

**NEVER** raise `HTTPException` from service layer. Define typed exceptions in domain-specific exception files:

```python
# services/exceptions.py - base exceptions only
class ServiceError(Exception):
    """Base service exception."""

class NotFoundError(ServiceError):
    """Resource not found."""

class ValidationError(ServiceError):
    """Validation error."""

# services/orders/exceptions.py - order domain
from app.services.exceptions import NotFoundError, ValidationError

class OrderNotFound(NotFoundError):
    """Order not found."""

class ImageNotFound(NotFoundError):
    """Image not found."""
```

## Code Organization Rules

### Complex Logic MUST Be Split

When a file exceeds ~200 lines or contains multiple distinct concerns:
- Split into a **folder** with multiple files
- Keep `__init__.py` empty (docstring only)
- Group related functionality together

Example:
```
# BAD: Single 1000-line file
app/api/v1/orders.py

# GOOD: Organized folder structure
app/api/v1/orders/
├── __init__.py           # Empty (docstring only)
├── schemas.py            # Pydantic models
├── dependencies.py       # FastAPI dependencies
├── order_routes.py       # Order CRUD
├── image_routes.py       # Image endpoints
└── coloring_routes.py    # Coloring endpoints
```

### Helper Functions MUST Be Extracted

- **NEVER** duplicate logic across files
- Extract shared helpers to appropriate utility modules
- Use `app/utils/` for cross-cutting utilities
- Use service-specific `_helpers.py` for domain helpers

### Dependency Injection Pattern

Use FastAPI's `Depends` with type aliases:

```python
# dependencies.py
async def get_order_service(session: Annotated[AsyncSession, Depends(get_session)]) -> OrderService:
    return OrderService(session)

OrderServiceDep = Annotated[OrderService, Depends(get_order_service)]

# routes.py
@router.get("/orders")
async def list_orders(service: OrderServiceDep) -> list[OrderResponse]:
    ...
```

## Pydantic Schemas

### Use `from_model` Factory Methods

```python
class OrderResponse(BaseModel):
    id: str  # ULID string
    order_number: str  # Display value
    status: str

    @classmethod
    def from_model(cls, order: Order) -> "OrderResponse":
        return cls(id=order.id, order_number=order.order_number, status=order.status.value)
```

### Datetime Serialization

Use the shared timezone helper:

```python
from app.utils.datetime_utils import to_api_timezone

@field_serializer("created_at")
def serialize_dt(self, dt: datetime) -> str:
    return to_api_timezone(dt).isoformat()
```

## HTTP Method Guidelines

| Action | Method | Notes |
|--------|--------|-------|
| Read resource | GET | |
| Create resource | POST | |
| Update resource state | PUT | e.g., selecting a version |
| Trigger action | POST | e.g., retry, sync, generate |
| Delete resource | DELETE | |

## Database Queries

### Eager Loading

Always use `selectinload` for related objects to avoid N+1 queries:

```python
select(Order).options(
    selectinload(Order.line_items)
    .selectinload(LineItem.images)
)
```

## Mercure Event Schemas (MANDATORY)

Mercure events MUST use typed Pydantic models defined in `app/models/events.py`:

- **NEVER** construct event JSON manually
- **ALWAYS** use `event.model_dump_json()` for serialization
- Event types: `OrderUpdateEvent`, `ListUpdateEvent`, `ImageUpdateEvent`, `ImageStatusEvent`
- All events use `order_id` (ULID string), not `shopify_id`

```python
from app.models.events import OrderUpdateEvent

event = OrderUpdateEvent(type="order_update", order_id=order_id)  # order_id is ULID string
await self._publish(topics=[...], data=event.model_dump_json())
```

The event schemas are exposed via `/api/v1/events/schema` endpoint for OpenAPI generation,
enabling type-safe frontend event handling through the generated SDK.

## Testing Considerations

- Services are independently testable (inject mock session)
- API routes can be tested with TestClient
- Exceptions provide clear failure modes
